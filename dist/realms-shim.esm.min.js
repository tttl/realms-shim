function throwTantrum(a,b=void 0){const c=`please report internal shim error: ${a}`;console.error(c),b&&(console.error(`${b}`),console.error(`${b.stack}`));debugger;throw c}function assert(a,b){a||throwTantrum(b)}function safeStringifyFunction(a){let b=`'use strict'; (${a})`;return b=b.replace(/\(0,\s*_[0-9a-fA-F]{3}\u200D\.e\)/g,"(0, eval)"),b=b.replace(/_[0-9a-fA-F]{3}\u200D\.g\./g,""),b=b.replace(/cov_[^+]+\+\+[;,]/g,""),b}function buildChildRealm(a,b){const{callAndWrapError:c}=a,{initRootRealm:d,initCompartment:e,getRealmGlobal:f,realmEvaluate:g}=b,{create:h,defineProperties:i}=Object;class j{constructor(){throw new TypeError("Realm is not a constructor")}static makeRootRealm(b={}){const e=h(j.prototype);return c(d,[a,e,b]),e}static makeCompartment(b={}){const d=h(j.prototype);return c(e,[a,d,b]),d}get global(){return c(f,[this])}evaluate(a,b,d={}){return c(g,[this,a,b,d])}}return i(j,{toString:{value:()=>"function Realm() { [shim code] }",writable:!1,enumerable:!1,configurable:!0}}),i(j.prototype,{toString:{value:()=>"[object Realm]",writable:!1,enumerable:!1,configurable:!0}}),j}const buildChildRealmString=safeStringifyFunction(buildChildRealm);function buildCallAndWrapError(){const{getPrototypeOf:a}=Object,{apply:b}=Reflect,c=a=>(c,...d)=>b(a,c,d),d=c(Map.prototype.get),e=c(Set.prototype.has),f=new Map([["EvalError",EvalError],["RangeError",RangeError],["ReferenceError",ReferenceError],["SyntaxError",SyntaxError],["TypeError",TypeError],["URIError",URIError]]),g=new Set([EvalError.prototype,RangeError.prototype,ReferenceError.prototype,SyntaxError.prototype,TypeError.prototype,URIError.prototype,Error.prototype]);return function(c,h){try{return b(c,void 0,h)}catch(b){if(Object(b)!==b)throw b;if(e(g,a(b)))throw b;let c,h,i;try{c=`${b.name}`,h=`${b.message}`,i=`${b.stack||h}`}catch(a){throw new Error("unknown error")}const j=d(f,c)||Error;try{throw new j(h)}catch(a){throw a.stack=i,a}}}}const buildCallAndWrapErrorString=safeStringifyFunction(buildCallAndWrapError),{assign,create,freeze,defineProperties,getOwnPropertyDescriptor,getOwnPropertyDescriptors,getOwnPropertyNames,getPrototypeOf,setPrototypeOf}=Object,{apply,ownKeys}=Reflect,uncurryThis=a=>(b,...c)=>apply(a,b,c),objectHasOwnProperty=uncurryThis(Object.prototype.hasOwnProperty),arrayFilter=uncurryThis(Array.prototype.filter),arrayPop=uncurryThis(Array.prototype.pop),arrayJoin=uncurryThis(Array.prototype.join),arrayConcat=uncurryThis(Array.prototype.concat),regexpTest=uncurryThis(RegExp.prototype.test),stringIncludes=uncurryThis(String.prototype.includes),frozenGlobalPropertyNames=["Infinity","NaN","undefined"],stableGlobalPropertyNames=["isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Array","ArrayBuffer","Boolean","DataView","EvalError","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Map","Number","Object","RangeError","ReferenceError","Set","String","Symbol","SyntaxError","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","URIError","WeakMap","WeakSet","JSON","Math","Reflect","escape","unescape"],unstableGlobalPropertyNames=["Date","Error","Promise","Proxy","RegExp","Intl"];function getSharedGlobalDescs(a,b=!1){function c(b,c,e,f){for(const g of b){const b=getOwnPropertyDescriptor(a,g);b&&(assert("value"in b,`unexpected accessor on global property: ${g}`),d[g]={value:b.value,writable:c,enumerable:e,configurable:f})}}const d={};return b?(c(frozenGlobalPropertyNames,!0,!1,!0),c(stableGlobalPropertyNames,!0,!1,!0)):(c(frozenGlobalPropertyNames,!1,!1,!1),c(stableGlobalPropertyNames,!1,!1,!1)),c(unstableGlobalPropertyNames,!0,!1,!0),d}function repairAccessors(){function a(a){return"symbol"==typeof a?a:`${a}`}function b(a,b){if("function"!=typeof a)throw TypeError(`invalid ${b} usage`);return a}const{defineProperty:c,defineProperties:d,getOwnPropertyDescriptor:e,getPrototypeOf:f,prototype:g}=Object;try{(0,g.__lookupGetter__)("x")}catch(a){return}const{apply:h}=Reflect,i=(a=>(b,...c)=>h(a,b,c))(g.valueOf),{__defineGetter__:j,__defineSetter__:k,__lookupGetter__:l,__lookupSetter__:m}={__defineGetter__(a,d){const e=i(this);c(e,a,{get:b(d,"getter"),enumerable:!0,configurable:!0})},__defineSetter__(a,d){const e=i(this);c(e,a,{set:b(d,"setter"),enumerable:!0,configurable:!0})},__lookupGetter__(b){let c=i(this);b=a(b);let d;for(;null!==c&&!(d=e(c,b));)c=f(c);return d&&d.get},__lookupSetter__(b){let c=i(this);b=a(b);let d;for(;null!==c&&!(d=e(c,b));)c=f(c);return d&&d.set}};d(g,{__defineGetter__:{value:j},__defineSetter__:{value:k},__lookupGetter__:{value:l},__lookupSetter__:{value:m}})}function repairFunctions(){function a(a,e){let f;try{f=(0,eval)(e)}catch(a){if(a instanceof SyntaxError)return;throw a}const g=c(f),h=function(){throw new TypeError("Not available")};b(h,{name:{value:a}}),b(g,{constructor:{value:h}}),b(h,{prototype:{value:g}}),h!==Function.prototype.constructor&&d(h,Function.prototype.constructor)}const{defineProperties:b,getPrototypeOf:c,setPrototypeOf:d}=Object;a("Function","(function(){})"),a("GeneratorFunction","(function*(){})"),a("AsyncFunction","(async function(){})"),a("AsyncGeneratorFunction","(async function*(){})")}const unsafeGlobalSrc="'use strict'; this",unsafeGlobalEvalSrc=`(0, eval)("'use strict'; this")`;function createNewUnsafeGlobalForNode(){const a=new Function("try {return this===global}catch(e){return false}")();if(!a)return;const b=require("vm"),c=b.runInNewContext(unsafeGlobalEvalSrc);return c}function createNewUnsafeGlobalForBrowser(){if("undefined"!=typeof document){const a=document.createElement("iframe");a.style.display="none",document.body.appendChild(a);const b=a.contentWindow.eval(unsafeGlobalSrc);return b}}const getNewUnsafeGlobal=()=>{const a=createNewUnsafeGlobalForBrowser(),b=createNewUnsafeGlobalForNode();if(!a&&!b||a&&b)throw new Error("unexpected platform, unable to create Realm");return a||b};function createUnsafeRec(a,b=[],c=!1){const d=getSharedGlobalDescs(a,c),e=a.eval,f=a.Function,g=e(buildCallAndWrapErrorString)();return freeze({unsafeGlobal:a,sharedGlobalDescs:d,unsafeEval:e,unsafeFunction:f,callAndWrapError:g,allShims:b})}const repairAccessorsString=safeStringifyFunction(repairAccessors),repairFunctionsString=safeStringifyFunction(repairFunctions);function createNewUnsafeRec(a,b=!1){const c=getNewUnsafeGlobal(),d=createUnsafeRec(c,a,b),{unsafeEval:e}=d;return e(repairAccessorsString)(),e(repairFunctionsString)(),d}function createCurrentUnsafeRec(){const a=eval,b=a(unsafeGlobalSrc);return repairAccessors(),repairFunctions(),createUnsafeRec(b)}const identifierPattern=/^[a-zA-Z_$][\w$]*$/,keywords=new Set(["await","break","case","catch","class","const","continue","debugger","default","delete","do","else","export","extends","finally","for","function","if","import","in","instanceof","new","return","super","switch","this","throw","try","typeof","var","void","while","with","yield","let","static","enum","implements","package","protected","interface","private","public","await","null","true","false","this","arguments"]);function getOptimizableGlobals(a,b={}){const c=getOwnPropertyNames(a),d=arrayFilter(c,c=>{if(c in b)return!1;if("eval"===c||keywords.has(c)||!regexpTest(identifierPattern,c))return!1;const d=getOwnPropertyDescriptor(a,c);return!1===d.configurable&&!1===d.writable&&objectHasOwnProperty(d,"value")});return d}function buildScopeHandler(a,b,c={},d=!1){const{unsafeGlobal:e,unsafeEval:f}=a,{freeze:g,getOwnPropertyDescriptor:h}=Object,{get:i,set:j}=Reflect,k=new Proxy(g({}),{get(a,b){throw new TypeError(`unexpected scope handler trap called: ${b+""}`)}});return{__proto__:k,useUnsafeEvaluator:!1,get(a,d){return"symbol"==typeof d?void 0:"eval"===d&&!0===this.useUnsafeEvaluator?(this.useUnsafeEvaluator=!1,f):d in c?i(c,d,b):i(b,d)},set(a,d,e){if(d in c){const a=h(c,d);return"value"in a?j(c,d,e):j(c,d,e,b)}return j(b,d,e)},has(a,f){return!!d||!!("eval"===f||f in c||f in b||f in e)},getPrototypeOf(){return null}}}const buildScopeHandlerString=safeStringifyFunction(buildScopeHandler);function buildSafeEval(a,b){const{callAndWrapError:c}=a,{defineProperties:d}=Object,e={eval(){return c(b,arguments)}}.eval;return d(e,{toString:{value:()=>`function ${"eval"}() { [shim code] }`,writable:!1,enumerable:!1,configurable:!0}}),e}const buildSafeEvalString=safeStringifyFunction(buildSafeEval);function buildSafeFunction(a,b){const{callAndWrapError:c,unsafeFunction:d}=a,{defineProperties:e}=Object,f=function(){return c(b,arguments)};return e(f,{prototype:{value:d.prototype},toString:{value:()=>"function Function() { [shim code] }",writable:!1,enumerable:!1,configurable:!0}}),f}const buildSafeFunctionString=safeStringifyFunction(buildSafeFunction);function applyTransforms(a,b){const{create:c,getOwnPropertyDescriptors:d}=Object,{apply:e}=Reflect,f=(a=>(b,...c)=>e(a,b,c))(Array.prototype.reduce);return a={src:`${a.src}`,endowments:c(null,d(a.endowments))},a=f(b,(a,b)=>b.rewrite?b.rewrite(a):a,a),a={src:`${a.src}`,endowments:c(null,d(a.endowments))},a}const applyTransformsString=safeStringifyFunction(applyTransforms),htmlCommentPattern=/(?:<!--|-->)/;function rejectHtmlComments(a){const b=a.search(htmlCommentPattern);if(-1!==b){const c=a.slice(0,b).split("\n").length;throw new SyntaxError(`possible html comment syntax rejected around line ${c}`)}}const importPattern=/\bimport\s*(?:\(|\/[/*])/,allowedImportPrefix=/@[a-z]+ +\{((type|key)of +)?$/s;function rejectImportExpressions(a){for(let b=0;;){const c=a.slice(b).search(importPattern);if(-1===c)return;if(b+=c,a.slice(0,b).match(allowedImportPrefix)){b+=1;continue}const d=a.slice(0,b).split("\n").length;throw new SyntaxError(`possible import expression rejected around line ${d}`)}}const someDirectEvalPattern=/\beval\s*(?:\(|\/[/*])/;function rejectSomeDirectEvalExpressions(a){const b=a.search(someDirectEvalPattern);if(-1!==b){const c=a.slice(0,b).split("\n").length;throw new SyntaxError(`possible direct eval expression rejected around line ${c}`)}}function rejectDangerousSources(a){rejectHtmlComments(a),rejectImportExpressions(a),rejectSomeDirectEvalExpressions(a)}const rejectDangerousSourcesTransform={rewrite(a){return rejectDangerousSources(a.src),a}};function buildOptimizer(a){return 0===a.length?"":`const {${arrayJoin(a,",")}} = this;`}function createScopedEvaluatorFactory(a,b){const{unsafeFunction:c}=a,d=buildOptimizer(b);return c(`
    with (arguments[0]) {
      ${d}
      return function() {
        'use strict';
        return eval(arguments[0]);
      };
    }
  `)}function createSafeEvaluatorFactory(a,b,c,d){const{unsafeEval:e}=a,f=e(applyTransformsString);return function(g={},h={}){const i=h.transforms||[],j=arrayConcat(i,c||[],[rejectDangerousSourcesTransform]);return function(c){let h={src:c,endowments:g};h=f(h,j);const i=getOptimizableGlobals(b,h.endowments),k=getOptimizableGlobals(h.endowments),l=arrayConcat(i,k),m=createScopedEvaluatorFactory(a,l),n=e(buildScopeHandlerString)(a,b,h.endowments,d),o=Proxy.revocable({},n),p=o.proxy,q=apply(m,b,[p]);n.useUnsafeEvaluator=!0;let r;try{return apply(q,b,[h.src])}catch(a){throw r=a,a}finally{n.useUnsafeEvaluator&&(o.revoke(),throwTantrum("handler did not revoke useUnsafeEvaluator",r))}}}}function createSafeEvaluator(a,b){const{unsafeEval:c,unsafeFunction:d}=a,e=c(buildSafeEvalString)(a,b);return assert(getPrototypeOf(e).constructor!==Function,"hide Function"),assert(getPrototypeOf(e).constructor!==d,"hide unsafeFunction"),e}function createSafeEvaluatorWhichTakesEndowments(a){return(b,c,d={})=>a(c,d)(b)}function createFunctionEvaluator(a,b){const{unsafeGlobal:c,unsafeEval:d,unsafeFunction:e}=a,f=d(buildSafeFunctionString)(a,function(...a){const d=`${arrayPop(a)||""}`;let f=`${arrayJoin(a,",")}`;if(!regexpTest(/^[\w\s,]*$/,f))throw new SyntaxError("shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names");if(new e(d),stringIncludes(f,")"))throw new c.SyntaxError("shim limitation: Function arg string contains parenthesis");0<f.length&&(f+="\n/*``*/");const g=`(function(${f}){\n${d}\n})`;return b(g)});return assert(getPrototypeOf(f).constructor!==Function,"hide Function"),assert(getPrototypeOf(f).constructor!==e,"hide unsafeFunction"),f}const RealmRecForRealmInstance=new WeakMap;function getRealmRecForRealmInstance(a){return assert(Object(a)===a,"bad object, not a Realm instance"),assert(RealmRecForRealmInstance.has(a),"Realm instance has no record"),RealmRecForRealmInstance.get(a)}function registerRealmRecForRealmInstance(a,b){assert(Object(a)===a,"bad object, not a Realm instance"),assert(!RealmRecForRealmInstance.has(a),"Realm instance already has a record"),RealmRecForRealmInstance.set(a,b)}function setDefaultBindings(a,b,c){defineProperties(a,{eval:{value:b,writable:!0,configurable:!0},Function:{value:c,writable:!0,configurable:!0}})}function createRealmRec(a,b,c){const{sharedGlobalDescs:d,unsafeGlobal:e}=a,f=create(e.Object.prototype,d),g=createSafeEvaluatorFactory(a,f,b,c),h=g(),i=createSafeEvaluator(a,h),j=createFunctionEvaluator(a,h),k=createSafeEvaluatorWhichTakesEndowments(g);setDefaultBindings(f,i,j);const l=freeze({safeGlobal:f,safeEval:i,safeEvalWhichTakesEndowments:k,safeFunction:j});return l}function initRootRealm(a,b,c){const{shims:d,transforms:e,sloppyGlobals:f,configurableGlobals:g}=c,h=arrayConcat(a.allShims,d),i=createNewUnsafeRec(h,g),{unsafeEval:j}=i,k=j(buildChildRealmString)(i,BaseRealm);i.sharedGlobalDescs.Realm={value:k,writable:!0,configurable:!0};const l=createRealmRec(i,e,f),{safeEvalWhichTakesEndowments:m}=l;for(const d of h)m(d);registerRealmRecForRealmInstance(b,l)}function initCompartment(a,b,c={}){const{transforms:d,sloppyGlobals:e}=c,f=createRealmRec(a,d,e);registerRealmRecForRealmInstance(b,f)}function getRealmGlobal(a){const{safeGlobal:b}=getRealmRecForRealmInstance(a);return b}function realmEvaluate(a,b,c={},d={}){const{safeEvalWhichTakesEndowments:e}=getRealmRecForRealmInstance(a);return e(b,c,d)}const BaseRealm={initRootRealm,initCompartment,getRealmGlobal,realmEvaluate},currentUnsafeRec=createCurrentUnsafeRec(),Realm=buildChildRealm(currentUnsafeRec,BaseRealm);export default Realm;
//# sourceMappingURL=realms-shim.esm.min.js.map
